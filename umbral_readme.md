# Proxy Re-Encryption Example Using Umbral

This Python script demonstrates a basic implementation of proxy re-encryption using the [Umbral library](https://github.com/nucypher/umbral-doc). It showcases how Alice can encrypt a message, decrypt it herself, and then delegate decryption rights to Bob through a threshold-based proxy re-encryption scheme.

## Overview

**Proxy re-encryption** is a cryptographic technique that enables a semi-trusted proxy to transform a ciphertext encrypted under one key (e.g., Alice's public key) into a ciphertext that can be decrypted under another key (e.g., Bob's private key), without the proxy ever accessing the plaintext. This is particularly useful for secure data sharing in scenarios where intermediaries should not have access to sensitive information.

In this example:
- Alice encrypts a message using her public key.
- Alice decrypts the message using her private key to verify the encryption.
- Alice generates key fragments that allow proxies to re-encrypt the ciphertext for Bob.
- Bob collects a threshold number of re-encrypted ciphertext fragments and decrypts the message using his private key.

The script employs a **threshold scheme**, where Alice splits her decryption capability into multiple key fragments (`shares`), and Bob needs a minimum number of these fragments (`threshold`) to decrypt the message. This adds flexibility and security by allowing decryption even if some fragments are unavailable.

## Prerequisites

To run this script, you need:
- **Python 3.x** installed on your system.
- The **Umbral library** installed. You can install it via pip:
  ```bash
  pip install umbral
  ```

## Code Explanation

The script performs the following steps:

### 1. Imports
The necessary classes and functions are imported from the Umbral library:
- `SecretKey`: For generating private and public keys.
- `Signer`: For signing key fragments.
- `encrypt`, `decrypt_original`: For encryption and decryption by the original key owner (Alice).
- `generate_kfrags`, `reencrypt`, `decrypt_reencrypted`: For proxy re-encryption and decryption by the delegate (Bob).

### 2. Parameters
The script defines:
- `plaintext = "This is Alice's message"`: The message to be encrypted.
- `threshold = 3`: The minimum number of fragments required for decryption.
- `shares = 5`: The total number of key fragments generated.

The plaintext is encoded into bytes for cryptographic operations:
```python
plain = plaintext.encode()
```

### 3. Key Generation
Random private and public key pairs are generated for Alice and Bob:
- Alice's keys:
  ```python
  alice_private_key = SecretKey.random()
  alice_public_key = alice_private_key.public_key()
  alice_signer = Signer(alice_private_key)
  ```
- Bob's keys:
  ```python
  bob_private_key = SecretKey.random()
  bob_public_key = bob_private_key.public_key()
  ```

The `alice_signer` is used to sign the key fragments, ensuring their authenticity.

### 4. Encryption
Alice encrypts the plaintext using her public key:
```python
capsule, ciphertext = encrypt(alice_public_key, plain)
```
- `capsule`: An object containing metadata needed for decryption and re-encryption.
- `ciphertext`: The encrypted message.

### 5. Decryption by Alice
Alice verifies the encryption by decrypting the ciphertext with her private key:
```python
cleartext = decrypt_original(alice_private_key, capsule, ciphertext)
```

### 6. Key Fragment Generation
Alice generates key fragments to delegate decryption rights to Bob:
```python
kfrags = generate_kfrags(delegating_sk=alice_private_key,
                         receiving_pk=bob_public_key,
                         signer=alice_signer,
                         threshold=threshold,
                         shares=shares)
```
- `kfrags`: A list of key fragments, where any `threshold` number of them can be used to re-encrypt the ciphertext for Bob.

### 7. Re-encryption Simulation
Bob collects the first `threshold` number of key fragments and simulates the re-encryption process:
```python
cfrags = list()
for kfrag in kfrags[:threshold]:
    cfrag = reencrypt(capsule=capsule, kfrag=kfrag)
    cfrags.append(cfrag)
```
- `cfrags`: A list of ciphertext fragments generated by applying `reencrypt` to each key fragment.

### 8. Decryption by Bob
Bob decrypts the re-encrypted ciphertext using his private key and the collected fragments:
```python
bob_cleartext = decrypt_reencrypted(receiving_sk=bob_private_key,
                                    delegating_pk=alice_public_key,
                                    capsule=capsule,
                                    verified_cfrags=cfrags,
                                    ciphertext=ciphertext)
```

### 9. Output
The script prints:
- The original plaintext, threshold, and shares.
- Alice's and Bob's private and public keys (for demonstration).
- The decrypted texts by Alice and Bob to verify the process.

## Usage

1. Ensure the prerequisites are met (Python and Umbral installed).
2. Save the script as `proxy_reencryption_example.py`.
3. Run the script:
   ```bash
   python proxy_reencryption_example.py
   ```
4. Observe the output, which will display the encryption and decryption results.

### Customizing Parameters
- The `plaintext`, `threshold`, and `shares` are hardcoded. To modify them:
  - Edit the values directly in the script, or
  - Uncomment the command-line argument section to pass values at runtime:
    ```python
    # import sys
    # if (len(sys.argv)>1):
    #   plaintext=str(sys.argv[1])
    # if (len(sys.argv)>2):
    #   threshold=int(sys.argv[2])
    # if (len(sys.argv)>3):
    #   shares=int(sys.argv[3])
    ```
    Then run, for example:
    ```bash
    python proxy_reencryption_example.py "New message" 2 4
    ```

## Notes

- **Random Keys**: Keys are generated randomly each time the script runs, so the output (e.g., key values) will differ per execution.
- **Simplified Example**: This script simulates proxies locally. In a real-world scenario, key fragments would be distributed to separate proxy entities, and Bob would collect ciphertext fragments from them.
- **Threshold Scheme**: The script requires `threshold` to be less than or equal to `shares`. Adjust these values as needed, ensuring `threshold <= shares`.

This example provides a foundation for understanding proxy re-encryption and can be extended for more complex use cases, such as distributed systems or secure file sharing.
